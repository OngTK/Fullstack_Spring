[ 동기 vs 비동기]
    - 프로그램 작업 처리 방식

    1) 동기
        - 여러 작업이 실행될 때, 작업 간의 실행 순서를 제어
        - 순차적 처리, 무결성 중시, 비교적 느림
    2) 비동기
        - 여러 작업이 실행될 때, 작업이 독립적으로 실행
        - 동시처리, 무결성 보장불가, 비교적 빠름

[ fetch 라이브러리 ]
    1) 정의
        JS에서 제공하며, 비동기 통신을 지원하는 함수
    2) 역할
        HTTP로부터 요청·응답을 비동기적으로 처리
    3) 비동기 방식 사용법
        : then을 이용한 체인 형식
    ```js
    fetch( URL , Option )
       .then( 응답매개변수 => 응답매개변수.타입 )
       .then( data => { 실행문; } )
       .catch( error => { 예외처리; } )
    ```
       (1) URL 주소
        - Spring @OOMapping에 할당된 URL 주소
       (2) Option
           ① { method : "http메소드" }
                : DELETE·GET 메소드 사용 시, headers / body 생략 가능
           ② { method : "http메소드" ,
                headers : { "Content-Type" : "application/json" } ,
                body : JSON.stringify( { 전달객체 } )     }
                   - 주로 body·headers를 사용하는 POST, PUT 메소드에서 사용
                   - header : http body의 타입 설정으로
                              `{ "Content-Type" : "application/json" }`을 항상 입력
                   - body : body로 전달할 객체 작성,
                            JSON 타입변환 필요( JSON.stringify() )
       (3) .then( 응답객체 => 응답객체.json() )
           - Java로 부터의 결과, 응답 자료·결과를 Json 타입으로 변환
           - 응답객체는 일반적으로 'response / r'
           - 응답객체.text : 응답객체를 문자 타입으로 반환
       (4) .then( data => { 실행문; } )
           - 타입변환된 자료를 매개변수로 받아 실행문 처리
       (5) .catch( error => { 실행문; } )
           - 만약에 fetch 통신 간에 오류가 발생할 경우, 실행문 처리

   4) 동기 방식 사용법
    - async · await 을 이용한 동기 형식
    - 실행 순서를 보장
       ```js
       const func = async () => {
          try{
               const response = await fetch( URL , Option )
               const data = await response.json()
           } catch ( error ) {
               console.log(error)
           }
       }
       ```
